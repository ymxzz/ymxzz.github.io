[{"title":"Good good study!","date":"2023-07-06T02:59:29.000Z","path":"2023/07/06/Good-good-study/","text":"正则表达式 https://www.runoob.com/python/python-reg-expressions.htmlre.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0) 替换字符串 pattern：该参数表示正则中的模式字符串； repl：该参数表示要替换的字符串（即匹配到pattern后替换为repl），也可以是个函数； string：该参数表示要被处理（查找替换）的原始字符串； count：可选参数，表示是要替换的最大次数，而且必须是非负整数，该参数默认为0，即所有的匹配都会被替换； flags：可选参数，表示编译时用的匹配模式（如忽略大小写、多行模式等），数字形式，默认为0。 按组group进行替换s = &quot;123,456,789&quot; 12re.sub(&#x27;(\\d+),&#x27;,&#x27;\\g&lt;1&gt;-&#x27;,s) # 或者 re.sub(&#x27;([0-9]+),&#x27;,&#x27;\\g&lt;1&gt;-&#x27;,s)&#x27;123-456-789&#x27; 12re.sub(&#x27;(\\d+),(\\d+)&#x27;,&#x27;\\g&lt;1&gt;-\\g&lt;2&gt;*&#x27;,s)&#x27;123-456*,789&#x27; \\d：表示一个十进制的数字 [0-9] \\D：表示非数字 \\w：表示一个字 [0－9a-zA-Z_] \\W：表示除[0－9a-zA-Z_]之外的字符 \\s：表示一个空白字符（空格，tab，换页符等） \\S：表示一个非空白字符 字符串里的是浮点数，直接转整型的话int(&#39;3.0&#39;)会报错所以得 12int(float(&#x27;3.0&#x27;))3","link":"","tags":[]},{"title":"算法题","date":"2023-06-30T10:57:22.000Z","path":"2023/06/30/python刷题/","text":"字符串[常见的字符串操作] https://docs.python.org/zh-cn/3/library/string.html#format-specification-mini-language字符串最后一个单词的长度： str.split() https://www.runoob.com/python/att-string-split.html 123456s = &quot;Hello world&quot;a = s.split()a[&#x27;Hello&#x27;, &#x27;world&#x27;]len(a[-1])5 计算某字符出现次数 1234a = input().lower()b = input().lower()print(a.count(b)) 字符串分隔 1234567891011s = input()res = list()while len(s)&gt;=8: res.append(s[:8]) s= s[8:]if len(s)&gt;0: res.append(s+(&quot;0&quot;*(8-len(s))))for i in res: print(i) 或者 123s = input().strip()for i in range(0,len(s),8): print(s[i:i+8].ljust(8,&#x27;0&#x27;)) # 左对齐 进制转换 123int(&quot;0x10&quot;,16)16 质数因子 c &#x3D; a*b a,b中至少一个数字小于等于根号a 1234567891011n = eval(input())# c = a*b# a,b中至少一个数字小于等于根号afor i in range(2, int(n**0.5)+1): while n % i == 0: print(i, end=&#x27; &#x27;) n = n//iif n &gt; 2: print(n) 取近似值 1234567n = eval(input())if n-int(n) &gt;=0.5: print(int(n+1))else: print(int(n)) 求最小公倍数（最大公约数） 1234567891011121314# 辗转相除法求最大公约数def gys(a,b): if b==0: return a return gys(b,a%b)num = input()a,b = map(int,num.split())if a&lt;b : a,b=b,ac = gys(a,b)# 最小公倍数*最大公约数 = a*bd = int((a*b)/c)print(d) 立方根 123456789101112# 二分num = float(input())l=-20r=20while(abs(r-l)&gt;0.01): x = (l+r)/2 if x*x*x &gt;num: r = x else: l = xprint(round(x,1)) # 保留一位小数 字符统计 123456789101112s = input()d = &#123;&#125;# 统计字符出现次数for i in s: if i not in d: d[i] = 0 d[i]+=1# -d[x]: 按值降序，x:按key升序print(*sorted(d,key=lambda x:(-d[x],x)),sep = &quot;&quot;)# sorted() https://www.runoob.com/python/python-func-sorted.html 合并表记录 1234567891011n = eval(input())d= dict()for i in range(n): index,value = map(int,input().split()) # d.get(index,0),index不存在返回0 d[index] = d.get(index,0)+value# 按照index值升序排列for i in sorted(d.keys(),key=lambda index:index): print(f&quot;&#123;i&#125; &#123;d[i]&#125;&quot;) 字符个数统计 12345s = input()# ord(),字符转为ASCII,判断是否在0~127之间s = set([i for i in s if 0&lt;=ord(i)&lt;=127])print(len(s)) 句子逆序 123s = input().strip().split()res = &quot; &quot;.join(s[::-1])print(res) 字符串排序 12345678n = eval(input())res = []for i in range(n): res.append(input())res.sort()for i in res: print(i) 求int型正整数在内存中存储时1的个数 1234s = eval(input())n = bin(s).count(&quot;1&quot;)print(n) HJ17 坐标移动 123456789101112131415a = [0,0]n = input().split(&quot;;&quot;)for i in n: if len(i)&gt;1: if i[0] == &#x27;A&#x27; and i[1:].isdigit(): a[0]-= int(i[1:]) elif i[0] == &#x27;D&#x27; and i[1:].isdigit(): a[0]+= int(i[1:]) elif i[0] == &#x27;W&#x27; and i[1:].isdigit(): a[1]+= int(i[1:]) elif i[0] == &#x27;S&#x27; and i[1:].isdigit(): a[1]-= int(i[1:])print(f&quot;&#123;a[0]&#125;,&#123;a[1]&#125;&quot;) HJ18 识别有效的IP地址和掩码并进行分类统计 正则表达式匹配https://leetcode.cn/problems/regular-expression-matching/偷懒做法12345class Solution: def isMatch(self, s: str, p: str) -&gt; bool: ss = re.findall(p,s) return len(ss) &gt; 0 and ss[0] == s HJ96.表示数字 123s = input()s = re.sub(&#x27;(\\d+)&#x27;,&#x27;*\\g&lt;1&gt;*&#x27;,s)print(s) 拓扑排序：LeetCode210 HJ23 删除字符串中出现次数最少的字符 12345678910111213d = &#123;&#125;s = input().strip()for i in s: d[i] = d.get(i,0)+1b = sorted(d,key=lambda x:d[x])s = s.replace(b[0],&quot;&quot;)for i in b: if d[i] == d[b[0]]: s = s.replace(i,&quot;&quot;)print(s) HJ29 字符串加解密 按要求分情况讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748s1 = input().strip()s2 = input().strip()# 加密def jiami(s): res = &quot;&quot; for i in s: if i.isupper() : # 如果是大写 if i == &#x27;Z&#x27;: res+= &#x27;a&#x27; else: res+= chr(ord(i)+32+1) elif i.islower(): # 如果是小写 if i == &#x27;z&#x27;: res+=&#x27;A&#x27; else: res+=chr(ord(i)-32+1) elif i.isdigit(): if int(i) == 9: res+=&#x27;0&#x27; else: res += str(int(i)+1) return res# 解密def jiemi(s): res = &quot;&quot; for i in s: if i.isupper() : # 如果是大写 if i == &#x27;A&#x27;: res+= &#x27;z&#x27; else: res+= chr(ord(i)+32-1) elif i.islower(): # 如果是小写 if i == &#x27;a&#x27;: res+=&#x27;Z&#x27; else: res+=chr(ord(i)-32-1) elif i.isdigit(): # 如果是数字 if int(i) == 0: res+=&#x27;9&#x27; else: res += str(int(i)-1) return resprint(jiami(s1))print(jiemi(s2)) HJ30 字符串合并处理https://www.nowcoder.com/practice/d3d8e23870584782b3dd48f26cb39c8f?tpId=37&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1&amp;sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D3%26tpId%3D37%26type%3D37 右对齐 123s = &quot;1&quot;s.rjust(4,&quot;0&quot;)&#x27;0001&#x27; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051d = &#123;&#x27;10&#x27;:&#x27;A&#x27;,&#x27;11&#x27;:&#x27;B&#x27;,&#x27;12&#x27;:&#x27;C&#x27;,&#x27;13&#x27;:&#x27;D&#x27;,&#x27;14&#x27;:&#x27;E&#x27;,&#x27;15&#x27;:&#x27;F&#x27;,\\ &#x27;A&#x27;:10,&#x27;B&#x27;:11,&#x27;C&#x27;:12,&#x27;D&#x27;:13,&#x27;E&#x27;:14,&#x27;F&#x27;:15&#125;s1 = &quot;&quot;s2 = &quot;&quot;l1 = [] # 奇数l2 = [] # 偶数s = input().strip().split()s = s[0]+s[1]# 按下表拆解排序/枚举for i,j in enumerate(s): # 奇偶判断 if i&amp;1 == 1: # 奇数 l1.append(j) else: l2.append(j)# 排序l1.sort()l2.sort()# 合并for i,j in zip(l2,l1): s1=s1+i+j# l1,l2长度不一样，会丢失一个元素 if len(l1)&gt;len(l2): s1+=l1[-1]elif len(l2)&gt;len(l1): s1+=l2[-1]for i in s1: if i.isdigit(): m = int(str(bin(int(i))).replace(&#x27;0b&#x27;,&#x27;&#x27;).rjust(4,&#x27;0&#x27;)[::-1],2) if m&gt;=10: s2 += d[str(m)] else: s2+=str(m) elif i in &quot;ABCDEFabcdef&quot;: i = i.upper() n = int(str(bin(int(d[i]))).replace(&#x27;0b&#x27;,&#x27;&#x27;).rjust(4,&#x27;0&#x27;)[::-1],2) if n&gt;=10: s2+= d[str(n)] else: s2+=str(n) else: s2+=iprint(s2) HJ61 放苹果递归 123456789101112131415# m个苹果，n个盘子#1.假设有一个盘子为空，则(m,n)问题转化为将m个苹果放在n-1个盘子上，即求得(m,n-1)即可# 2.假设所有盘子都装有苹果，则每个盘子上至少有一个苹果，即最多剩下m-n个苹果，问题转化为将m-n个苹果放到n个盘子上，即求(m-n，n)def fn(m,n): if m&lt;0 or n&lt;0: # 没有盘子或者苹果的时候0种放法 return 0 elif m == 1 or n == 1: # 只有1个苹果或者盘子，1种放法 return 1 return fn(m,n-1)+fn(m-n,n) m,n = map(int, input().strip().split())print(fn(m,n)) HJ67. 24点游戏算法 12345678910111213141516171819202122def fn(arr:list): if not arr: return False if len(arr) == 1: return abs(abs(arr[0])-24) &lt; 0.00001 for i in range(len(arr)): for j in range(i+1,len(arr)): a1,a2 = arr[i],arr[j] a = arr[:i]+arr[i+1:j]+arr[j+1:] if fn([a1+a2]+a): return True if fn([a1-a2]+a): return True if fn([a1*a2]+a): return True if a2!=0: if fn([a1/a2]+a): return Truen = list(map(int, input().strip().split()))print(&quot;true&quot; if fn(n) else &quot;false&quot;) Leetcode 盛最多水的容器 1234567891011121314class Solution: def maxArea(self, height: List[int]) -&gt; int: res = 0 l = 0 r = len(height)-1 while l&lt;r: V = (r-l)*min(height[l],height[r]) res = max(res,V) # 矮的那一边移动 if height[l] &lt; height[r]: l+=1 elif height[l] &gt;= height[r]: r-=1 return res 接雨水 123456789101112class Solution: def trap(self, height: List[int]) -&gt; int: res = 0 hl=0 hr=0 for i in range(len(height)): hl = max(hl,height[i]) hr = max(hr,height[-i-1]) # 从-0-1开始 res += hl+hr # 减去重叠部分 和 柱子的总面积 return res -len(height)*hl-sum(height) 无重复字符的最长子串 1234567891011121314151617181920class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if len(s) == 0: return 0 if len(s) == 1: return 1 l = r = count = res = 0 while r &lt; len(s)-1: # r+1 &lt; len(s) # r先移动 r+=1 # 如果 r和l指向字符相同，l也移动 if s[r] == s[l]: l+=1 # 遍历l~r间的字符，如果字符有和r指向字符相同，l指向该字符下一个 for j in range(l,r): if s[j] == s[r]: l=j+1 count = r-l+1 res = max(res, count) return res 二叉树的最大深度 12345678910111213class Solution: def maxDepth(self, root: Optional[TreeNode]) -&gt; int: def fn(root): if not root: return 0 l = fn(root.left) r = fn(root.right) return max(l,r)+1 return fn(root) 岛屿数量DFS（深度优先搜索）https://leetcode.cn/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/ 123456789101112131415161718192021222324252627class Solution: def numIslands(self, grid: List[List[str]]) -&gt; int: def dfs(grid:list ,r: int ,c: int): # 判断坐标（r,c）是否超出网格范围,不在则返回 if not (0&lt;= r &lt;len(grid) and 0 &lt;= c &lt; len(grid[0])): return False if grid[r][c] != &#x27;1&#x27;: return False grid[r][c] = &#x27;2&#x27; # 把遍历过的点标记为2,避免重复遍历 # 上，下，左，右 dfs(grid,r-1,c) dfs(grid,r+1,c) dfs(grid,r,c-1) dfs(grid,r,c+1) res = 0 for r in range(0,len(grid)): for c in range(0,len(grid[0])): if grid[r][c] == &#x27;1&#x27;: dfs(grid,r,c) res+=1 return res 二叉树中的最大路径和 12345678910111213141516171819class Solution: def maxPathSum(self, root: Optional[TreeNode]) -&gt; int: self.res = root.val def fn(root): if not root: return 0 m = root.val l = max(0,fn(root.left)) r = max(0,fn(root.right)) self.res = max(self.res, root.val+l+r) return root.val+max(l,r) fn(root) return self.res 求根节点到叶节点数字之和 123456789101112131415161718192021class Solution: def sumNumbers(self, root: Optional[TreeNode]) -&gt; int: self.res = 0 def fn(root,num): num = num*10+ root.val if (not root.left) and (not root.right): self.res+=num if root.left: fn(root.left,num) if root.right: fn(root.right,num) fn(root,0) return self.res 96 不同的二叉搜索树https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/ 1234567891011121314class Solution: def numTrees(self, n: int) -&gt; int: G = [0]*(n+1) # 长度为0或者1时只有一种 G[0] = 1 G[1] = 1 for i in range(2,n+1): for j in range(1,i+1):# j为根，(从1开始)长度为i # 动态规划 G[i] += G[j-1]*G[i-j] return G[n] 买卖股票的最佳时机 II 1234567891011class Solution: def maxProfit(self, prices: List[int]) -&gt; int: res = 0 # 只要后一天比前一天大 就把这两天的差值加一下 # 从1开始 for i in range(1,len(prices)): if prices[i]&gt;prices[i-1]: res+= prices[i]-prices[i-1] return res 买卖股票的最佳时机 IIIhttps://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/comments/10086 斐波那契数 123456789101112131415161718class Solution(object): def fib(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n == 0: return 0 if n==1: return 1 a = 0 b = 1 for i in range(2,n+1): a,b = b,a+b return b 爬楼梯(斐波那契) 12345678910class Solution: def climbStairs(self, n: int) -&gt; int: a,b = 1,2 if n == 1: return 1 if n == 2: return 2 for i in range(3,n+1): # or range(n-2) a,b = b, a+b return b 路径总和1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution: def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool: def fn(root,targetSum): if not root: return False if root.left == None and root.right == None: return targetSum - root.val == 0 return fn(root.left,targetSum-root.val) or fn(root.right,targetSum-root.val) return fn(root,targetSum) 12345678910111213class Solution(object): def hasPathSum(self, root, targetSum): &quot;&quot;&quot; :type root: TreeNode :type targetSum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right: return targetSum == root.val return self.hasPathSum(root.left,targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val) 分治：LeetCode23. 合并 K 个升序链表 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -&gt; Optional[ListNode]: l=[] def fn(ListNode): if not ListNode: return l.append(ListNode.val) fn(ListNode.next) for i in lists: fn(i) # 如果 l=[]...即lists情况为 []或[[]]... if not l: return None l.sort() res = ListNode(l[0]) r = res for i in range(1,len(l)): r.next = ListNode(l[i]) r = r.next return res 多数元素123456789class Solution: def majorityElement(self, nums: List[int]) -&gt; int: d = &#123;&#125; for i in nums: d[i] = d.get(i,0)+1 for k in d: if d[k] &gt; len(nums)/2: return k 240 单调栈：LeetCode84. 柱状图中最大的矩形 123456789101112131415class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: heights = [0] + heights +[0] stack = [] res =0 for i in range(len(heights)): while stack and heights[stack[-1]]&gt;heights[i]: h = heights[stack.pop()] w = i -stack[-1] -1 res = max(res, h*w) stack.append(i) return res 85、739. 每日温度 1234567891011121314class Solution: def dailyTemperatures(self, temperatures: List[int]) -&gt; List[int]: n = len(temperatures) res = [0]*n stack = [] for i in range(n): #盏顶温度低于第i天的温度，出栈 while stack and temperatures[stack[-1]]&lt;temperatures[i]: m = stack.pop() res[m] = i-m stack.append(i) return res 下一个更大元素 II123456789101112131415161718192021class Solution: def nextGreaterElements(self, nums: List[int]) -&gt; List[int]: n = len(nums) res = [-1]*n stack = [] i = 0 c = 0 while True: while stack and nums[stack[-1]] &lt; nums[i]: m = stack.pop() res[m] = nums[i] stack.append(i) i+=1 if i == n: i=0 c+=1 if c ==2: # 循环两遍跳出 break return res 冗余连接 并查集：LeetCode547、200、684滑动窗口：LeetCode209 长度最小的子数组 123456789101112131415161718class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: n = len(nums) res = n+1 r=l=0 t_sum = 0 while r&lt;n: t_sum += nums[r] # 窗口内的和大于target,l移动 while t_sum &gt;= target: res = min(res,r-l+1) t_sum-=nums[l] l+=1 r+=1 return 0 if res == n+1 else res 无重复字符的最长子串 123456789101112131415161718192021class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if len(s) == 0: return 0 if len(s) == 1: return 1 l = r = count = res = 0 while r &lt; len(s)-1: # r+1 &lt; len(s) # r先移动 r+=1 # 如果 r和l指向字符相同，l也移动 if s[r] == s[l]: l+=1 # 遍历l~r间的字符，如果字符有和r指向字符相同，l指向该字符下一个 for j in range(l,r): if s[j] == s[r]: l=j+1 count = r-l+1 res = max(res, count) return res 最大连续1的个数 III 12345678910111213141516171819202122232425class Solution: def longestOnes(self, nums: List[int], k: int) -&gt; int: l=0 r=0 n = len(nums)-1 c0 = 0 res = 0 while r &lt;= n: # 计数0 if nums[r] == 0: c0+=1 # 0的个数大于k, l移动，并且l指向0则，0计数减一 while c0 &gt; k: if nums[l] == 0: c0-=1 l+=1 res = max(res,r-l+1) # 返回最大窗口长度 r+=1 return res 尽可能使字符串相等 二分查找：LeetCode33、34前缀和： 寻找数组的中心下标12345678910111213141516class Solution: def pivotIndex(self, nums: List[int]) -&gt; int: n = len(nums) total = sum(nums) sl = 0 for i in range(n): # 左和加当前数值等于总和，则返回i if sl*2+nums[i] == total: return i sl+=nums[i] return -1 https://leetcode.cn/problems/subarray-sum-equals-k/solution/qian-zhui-he-zi-dian-ji-jian-python-by-y-yaub/ 123456789101112class Solution(object): def subarraySum(self, nums, k): s = 0 res = 0 d = &#123;0:1&#125; # s-k == 0,则有一组和为k的子数组 for i in range(len(nums)): s+=nums[i] res += d.get(s-k,0) # 如果s[i]-k = s[j]，也有一组 d[s] = d.get(s,0)+1 return res 路径总和 III 1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = right# 两层递归class Solution: # 第一层 def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int: # 第二层 def fn(root,t): res = 0 if not root: return 0 if t==root.val: res+=1 res+=fn(root.left,t-root.val) res+=fn(root.right,t-root.val) return res if not root: return 0 res = fn(root,targetSum) res += self.pathSum(root.left,targetSum) res += self.pathSum(root.right,targetSum) return res 统计「优美子数组」 字典树：LeetCode 找到最终的安全状态 矩形面积 1234567891011121314151617181920class Solution: def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -&gt; int: w = 0 h = 0 s1 = (ax2-ax1)*(ay2-ay1) s2 = (bx2-bx1)*(by2-by1) if s1 ==0: return s2 if s2 == 0: return s1 w = min(ax2,bx2) - max(ax1,bx1) h = min(ay2,by2) - max(ay1,by1) s = max(w,0)*max(h,0) return s1+s2 - s 岛屿的最大面积 12345678910111213141516171819202122232425262728293031323334353637class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: def fn(grid,r,c): # 边界判断,超出返回0 if not (0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0])): return 0 res = 0 if grid[r][c] != 1: return 0 if grid[r][c] == 1: res+=1 grid[r][c] = 0 res += fn(grid,r-1,c) # 上 res += fn(grid,r+1,c) # 下 res += fn(grid,r,c-1) # 左 res += fn(grid,r,c+1) # 右 return res m = len(grid) n = len(grid[0]) res = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: res = max(res,fn(grid,i,j)) return res 动态规划：LeetCode213 打家劫舍 1234567891011121314151617class Solution: def rob(self, nums: List[int]) -&gt; int: # res = max(dp[i]+dp[i-2], dp[i-1]) if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0]*2 dp[0] = nums[0] dp[1] = max(nums[0],nums[1]) for i in range(2,len(nums)): dp[0],dp[1] = dp[1],max(dp[1], dp[0] + nums[i]) return dp[1] 或 1234cur = pre = 0for i in nums: pre, cur = cur, max(cur,pre+i)return cur 打家劫舍II 12345678910111213141516171819class Solution(object): def rob(self, nums): if not nums: return 0 if len(nums)==1: return nums[0] p1,c1 = 0,0 for i in nums[1:]: # 第一个不偷 2-n p1,c1 = c1, max(c1,p1+i) p2,c2 = 0,0 for i in nums[:-1]: # 最后一个不偷 1-(n-1) p2,c2 = c2, max(c2,p2+i) return max(c1,c2) 1234567891011121314151617class Solution: def rob(self, nums: List[int]) -&gt; int: if not nums: return 0 n = len(nums) def myrob(nums): pre = 0 cur = 0 for x in nums: pre , cur = cur, max(cur, pre+x) print(pre,cur) return cur res1 = nums[0] + myrob(nums[2:-1]) # 第一个偷 0-(n-1) res2 = myrob(nums[1:]) # 第一个不偷 1-n return max(res2,res1) 排序HJ26 字符串排序 123456789101112131415161718s = input().strip()a = &#x27;&#x27;for i in s: if i.isalpha(): a+=i # 把字母排序，key=str.lower忽略大小写a = sorted(a,key=str.lower) res = &#x27;&#x27;index = 0 # 用来索引a中的字母for i in s: # 是字母的话，替换为 if i.isalpha(): res += a[index] index += 1 # a中拿走一个字母，index移动下一位 else: res += iprint(res) 最长回文子串1234567891011121314151617181920212223242526class Solution: def longestPalindrome(self, s: str) -&gt; str: n = len(s) l=0 r=0 res = &#x27;&#x27; if len(s) == 1: return s for i in range(n): #只需要找长度大于res的子串 # 奇数回文，从i向左找子串 l = max(i-len(res)-1,0) #- len(s) #左，偶(奇) t = s[l:i+1] if t == t[::-1]: res = t # 右，奇（偶） else: t = t[1:] if t == t[::-1]: res = t return res HJ43 迷宫问题 123456789101112131415161718192021222324252627282930313233343536def fn(grid,r,c,res = [(0,0)]): m,n = len(grid),len(grid[0]) if c+1 &lt; n and grid[r][c+1] == 0: # 向右 if (r,c+1) not in res: fn(grid,r,c+1,res+[(r,c+1)]) if c-1 &gt;= 0 and grid[r][c-1] == 0: # 向左 if (r,c-1) not in res: fn(grid,r,c-1,res+[(r,c-1)]) if r+1 &lt; m and grid[r+1][c] == 0: # 向下 if (r+1,c) not in res: fn(grid,r+1,c,res+[(r+1,c)]) if r-1 &gt;= 0 and grid[r-1][c] == 0: # 向上 if (r-1,c) not in res: fn(grid,r-1,c,res+[(r-1,c)]) if r == m-1 and c == n-1: # 如果走出去了 for i in res: print(f&quot;(&#123;i[0]&#125;,&#123;i[1]&#125;)&quot;) while True: try: m,n = map(int,input().split()) grid = [] for i in range(m): grid.append(list(map(int,input().split()))) fn(grid,0,0) except: break 字符串压缩https://blog.csdn.net/wtswts1232/article/details/130152165 栈123456789101112131415161718192021222324252627s = &quot;&#123;A3B1&#123;C&#125;3&#125;3&quot;def fn(s): res = [] n = len(s) for i in range(n): if s[i] == &#x27;&#123;&#x27;: res.append(s[i]) if s[i].isalpha(): res.append(s[i]) if s[i].isdigit() and res[-1].isalpha(): res.append(res.pop()*int(s[i])) if s[i] == &#x27;&#125;&#x27;: temp = &#x27;&#x27; while res[-1]!=&#x27;&#123;&#x27;: temp += res.pop() temp = temp[::-1] res.pop() # pop出 &#123; res.append(temp*int(s[i+1])) res.append(s[i]) return resfor i in fn(s)[0]: if i !=&#x27;&#125;&#x27;: print(i,end=&#x27;&#x27;) # AAABCCCAAABCCCAAABCCC 有效的括号12345678910111213class Solution(object): def isValid(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; while True: s = s.replace(&#x27;()&#x27;,&#x27;&#x27;) s = s.replace(&#x27;[]&#x27;,&#x27;&#x27;) s = s.replace(&#x27;&#123;&#125;&#x27;,&#x27;&#x27;) # 当 () &#123;&#125; []都不在s里时，退出循环 if &#x27;()&#x27; not in s and &#x27;[]&#x27; not in s and &#x27;&#123;&#125;&#x27; not in s: return s == &#x27;&#x27; 栈123456789101112131415161718192021class Solution: def isValid(self, s: str) -&gt; bool: stack = [] l = [&#x27;()&#x27;,&#x27;[]&#x27;,&#x27;&#123;&#125;&#x27;] # 有效的括号 if not s: return False # 如果都是有效括号，i为右括号的时候，i-1为对应的左括号 for i in s: if i in [&#x27;(&#x27;,&#x27;[&#x27;,&#x27;&#123;&#x27;]: stack.append(i) else: # 没有 ([&#123;的话 即为 )]&#125; if not stack: # stack为空 i为反括号 return False else: # 不为空,i为反括号,stack[-1]与i进行匹配看是否为有效的括号 if stack.pop()+i not in l: return False if not stack: # 左括号与右括号都匹配完，stack为空 return True return False 字符串相乘偷懒方法 return str(int(num1)*int(num2)) 1 贪心算法：LeetCode55贪心算法：找到每个阶段局部最优，推出全局最优贪心算法一般分为如下四步： 将问题分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 跳跃游戏(贪心) 1234567891011121314151617181920class Solution: def canJump(self, nums: List[int]) -&gt; bool: if len(nums) == 1: return True cover = 0 i=0 # python不支持动态修改for循环中变量,使用while循环代替 while i &lt;= cover: # 覆盖范围不断更新 cover = max(i+nums[i],cover) # 动态更新最大覆盖范围 print(i) if cover &gt;= len(nums)-1: # 覆盖整个数组则返回True return True i+=1 return False 无重叠区间(贪心)","link":"","tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"base64图片插入","date":"2023-06-23T04:37:33.000Z","path":"2023/06/23/base64图片插入/","text":"概述Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。 Base64 常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括 MIME 的电子邮件及 XML 的一些复杂数据。 图片的 BASE64 编码就是可以将一幅图片数据编码成一串字符串，使用该字符串代替图片地址，从而不需要使用图片的 URL 地址。 一个图片转base64编码的在线网站：https://c.runoob.com/front-end/59/ 直接插入文本，就不需要建立图床，通过链接引用了。markdown文档插入方式：![image](base64)示例：","link":"","tags":[]},{"title":"SQL刷题笔记","date":"2023-06-11T12:27:38.000Z","path":"2023/06/11/SQL刷题/","text":"超过经理收入的员工 自连接：把一张表 当做多个表使用eg.select …from 表 a（别名）join 表 b（别名） on a.字段&#x3D;b.字段 12select e1.name as Employee from Employee e1,Employee e2 where e1.managerId = e2.id and e1.salary &gt; e2.salary; 查找重复的电子邮箱 https://leetcode.cn/problems/duplicate-emails/有时候，遇到数据库重复数据，需要将数据进行分组，并取出其中一条来展示，这时就需要用到group by语句。having 用于筛选分组后的数据 1select email from Person group by email having count(email) &gt;1; 组合两个表https://leetcode.cn/problems/combine-two-tables/ 1select firstName,lastName,city ,state from Person left join Address on Person.PersonId = Address.PersonId; 从不订购的客户https://leetcode.cn/problems/customers-who-never-order/ 1select Name as Customers from Customers where Id not in (select distinct CustomerId from Orders); 删除重复的电子邮箱https://leetcode.cn/problems/delete-duplicate-emails/ 1delete p1 from Person p1, person p2 where p1.email = p2.email and p1.id&gt;p2.id; 上升的温度https://leetcode.cn/problems/rising-temperature/日期函数：datediff 两个日期的天数差集eg.DATEDIFF(‘2007-12-31’,’2007-12-30’); # 1DATEDIFF(‘2010-12-30’,’2010-12-31’); # -1 123select w1.id from Weather w1,Weather w2 where datediff(w1.recordDate,w2.recordDate)=1 and w1.temperature &gt; w2.temperature; 连续出现的数字https://leetcode.cn/problems/consecutive-numbers/123456789select distinct l1.Num as ConsecutiveNumsfrom Logs l1, Logs l2, Logs L3where# id是否连续l1.id = l2.id-1 and l2.id = l3.id-1 and# Num是否相等l1.Num = l2.Num and l2.Num = l3.Num","link":"","tags":[{"name":"SQL刷题笔记","slug":"SQL刷题笔记","permalink":"http://example.com/tags/SQL%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}]},{"title":"虚析构函数","date":"2023-06-06T02:56:30.000Z","path":"2023/06/06/虚析构函数/","text":"基类的虚析构函数使得某些情况下释放内存时能调用派生类的析构函数，避免内存泄漏 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class A&#123;public: A()&#123;std::cout&lt;&lt;&quot;A被创建~&quot;&lt;&lt;std::endl;&#125; //构造函数：实例化对象时被调用的方法 virtual ~A()&#123;std::cout&lt;&lt;&quot;A被销毁~&quot;&lt;&lt;std::endl;&#125; //析构函数：销毁对象（释放内存）时被调用的方法&#125;;class B : public A&#123;public: B()&#123;std::cout&lt;&lt;&quot;B被创建~&quot;&lt;&lt;std::endl;&#125; ~B()&#123;std::cout&lt;&lt;&quot;B被销毁~&quot;&lt;&lt;std::endl;&#125;&#125;;int main()&#123; A* a = new A; delete a; //A被创建~ //A被销毁~ B* b = new B; delete b; //A被创建~ //B被创建~ //B被销毁~ //A被销毁 A* c = new B; delete c; //A被创建~ //B被创建~ //A被销毁~ //只有基类A的的析构函数被调用，派生类B的没有调用，可能造成内存泄漏，所以需要把基类A的析构函数改为虚函数，才会先调用派生类B的析构函数，再调用基类A的 &#125; 12345class A&#123;public: A()&#123;std::cout&lt;&lt;&quot;A被创建~&quot;&lt;&lt;std::endl;&#125; 时被调用的方法 virtual ~A()&#123;std::cout&lt;&lt;&quot;A被销毁~&quot;&lt;&lt;std::endl;&#125; //改为虚析构函数&#125;; 1234567 A* c = new B;delete c; //A被创建~//B被创建~//B被销毁~//A被销毁~","link":"","tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"C++刷题笔记","date":"2023-06-04T12:33:01.000Z","path":"2023/06/04/C++刷题笔记/","text":"当数组名字作为函数实参传递1234567int foo(char x[10])&#123; return sizeof(x);&#125;int main()&#123; char a[10]; std::cout&lt;&lt; foo(a);&#125; -当数组名字作为函数实参传递时会退化为指针，此处打印指针的大小，32位指针大小为4，64为则为8-打印： 8 (32位的话打印4) C语言的三种基本控制结构（） 无重复字符的最长子串 https://leetcode.cn/problems/longest-substring-without-repeating-characters/给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 1234567891011121314151617181920212223242526272829class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int l = 0; int r = 0; int count = 0; int res = 0; if(s.size()== 0) return 0; if(s.size() == 1) return 1; while(s[r+1])&#123; r += 1; //如果l,r指向内容相同，l移动 if (s[r] == s[l])&#123; l+=1; &#125; //遍历l~r间的内容 ,若过程中有元素与r指向内容相同，则l指向下一个内容,&#x27;dvsv&#x27;-&gt;&#x27;sv&#x27; for(int j = l; j &lt; r; j++)&#123; if(s[j] == s[r])&#123; l=j+1; &#125; &#125; count = r-l+1; res = max(res,count); &#125; return res; &#125;&#125;;","link":"","tags":[{"name":"C++刷题笔记","slug":"C-刷题笔记","permalink":"http://example.com/tags/C-%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","date":"2023-06-02T08:05:06.844Z","path":"2023/06/02/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"","tags":[]},{"title":"Django学习","date":"2022-06-29T05:05:30.000Z","path":"2022/06/29/Django学习/","text":"Django：web应用框架 采用了 MVT 的软件设计模式，即模型（Model），视图（View）和模板（Template）。 MVT模型（Model）: 编写程序应有的功能，负责业务对象与数据库的映射（ORM）。 视图（View）：负责业务逻辑，并在适当时候调用Model和Template。 模板（Template）：负责如何吧页面展示给用户。 MVC模型（Model）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。 视图（View）- 图形界面，负责与用户的交互(页面)。 控制器（Controller）- 负责转发请求，对请求进行处理。 pip安装django 123&gt;&gt;&gt; import django &gt;&gt;&gt; django.get_version()&#x27;4.2.2 Django创建一个项目使用django-admin管理工具django-admin startproject HelloWorld 123456789101112131415C:\\Users\\ggh\\Desktop\\helloworldλ tree/f卷 系统 的文件夹 PATH 列表卷序列号为 1407-662CC:.└─HelloWorld │ manage.py │ └─HelloWorld asgi.py settings.py urls.py wsgi.py __init__.py 目录说明： HelloWorld: 项目的容器。 manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。 HelloWorld/__init__.py: 一个空文件，告诉 Python 该目录是一个 Python 包。 HelloWorld/asgi.py: 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目。 HelloWorld/settings.py: 该 Django 项目的设置/配置。 HelloWorld/urls.py: 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&quot;目录&quot;。 HelloWorld/wsgi.py: 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。 使用manage.py启动服务器python manage.py runserver 0.0.0.0:80000.0.0.0 让其它电脑可连接到开发服务器，8000 为端口号。如果不说明，那么端口号默认为 8000。 视图和url配置HelloWorld 目录下的 HelloWorld 目录新建一个 views.py 文件views.py 1234from django.http import HttpResponsedef hello(request): return HttpResponse(&quot;Hello World!&quot;) urls.py 12345678from django.contrib import adminfrom django.urls import pathfrom . import viewsurlpatterns = [ path(&#x27;admin/&#x27;, admin.site.urls), path(&#x27;hello/&#x27;,views.hello)] 访问http://127.0.0.1:8000/hello/,显示了Hello World! path() 函数Django path() 可以接收四个参数，分别是两个必选参数：route、view 和两个可选参数：kwargs、name。 语法格式：path(route, view, kwargs&#x3D;None, name&#x3D;None) route: 字符串，表示 URL 规则，与之匹配的 URL 会执行对应的第二个参数 view。 view: 用于执行与正则表达式匹配的 URL 请求。 kwargs: 视图使用的字典类型的参数。 name: 用来反向获取 URL。","link":"","tags":[]},{"title":"MySQL学习","date":"2022-06-06T11:42:54.000Z","path":"2022/06/06/MySQL学习/","text":"-数据库：按照数据结构来组织、存储和管理数据的仓库 -SQL (Structured query language结构化查询语言)： 是一门用于访问和处理数据库(如MySQL、SQL Server、Access等)的标准的计算机语言，范围包括数据的增删改查，数据库模式创建和修改，数据访问控制。 MySQL下载：https://dev.mysql.com/downloads/mysql/ 解压文件夹下配置 my.ini 安装配置： https://www.runoob.com/mysql/mysql-install.html 登录： mysql -u root -p mysql版本： mysql&gt; select version(); +-----------+ | version() | +-----------+ | 8.0.33 | +-----------+ 1 row in set (0.00 sec) 修改密码： mysqladmin -u用户名 -p旧密码 password 新密码 mysqladmin -uroot -pE6laBikl.SN4 password 12345 SQL基础语法增INSERT INTO 语句INSERT INTO 语句用于向表中插入新记录。SQL INSERT INTO 语法INSERT INTO 语句可以有两种编写形式。第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： INSERT INTO table_name VALUES (value1,value2,value3,...);第二种形式需要指定列名及被插入的值： INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...); mysql&gt; insert into mydatabase_tbl values (4,&#39;亿贫如洗&#39;,&#39;王道长&#39;,&#39;2023,06,11&#39;); Query OK, 1 row affected, 1 warning (0.01 sec) mysql&gt; insert into mydatabase_tbl (mydatabase_title,mydatabase_author,submission_date) values (&#39;一念之插&#39;,&#39;张灵玉&#39;,&#39;2023-06-11&#39;); Query OK, 1 row affected (0.00 sec) mysql&gt; select * from mydatabase_tbl; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 1 | MySQL学习 | YM学渣 | 2023-06-08 | | 2 | 阿威十八式 | 宝儿姐 | 2023-06-10 | | 3 | 不摇碧莲 | 张楚岚 | 2023-06-10 | | 4 | 亿贫如洗 | 王道长 | 2023-06-11 | | 5 | 一念之插 | 张灵玉 | 2023-06-11 | +---------------+------------------+-------------------+-----------------+ 5 rows in set (0.00 sec) 删DELETE 语句DELETE 语句用于删除表中的行。SQL DELETE 语法DELETE FROM table_name WHERE condition; mysql&gt; delete from mydatabase_tbl where mydatabase_id=1; Query OK, 1 row affected (0.00 sec) mysql&gt; select * from mydatabase_tbl; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 2 | 机智一匹 | 宝儿姐 | 2023-06-10 | | 3 | 不摇碧莲 | 张楚岚 | 2023-06-10 | | 4 | 亿贫如洗 | 王道长 | 2023-06-11 | | 5 | 一念之插 | 张灵玉 | 2023-06-11 | +---------------+------------------+-------------------+-----------------+ 4 rows in set (0.00 sec) 改UPDATE 语句UPDATE 语句用于更新表中已存在的记录。SQL UPDATE 语法UPDATE table_name SET column1 = value1, column2 = value2, ...WHERE condition; mysql&gt; update mydatabase_tbl set mydatabase_title=&#39;机智一匹&#39; where mydatabase_id=2; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql&gt; select * from mydatabase_tbl; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 1 | MySQL学习 | YM学渣 | 2023-06-08 | | 2 | 机智一匹 | 宝儿姐 | 2023-06-10 | | 3 | 不摇碧莲 | 张楚岚 | 2023-06-10 | | 4 | 亿贫如洗 | 王道长 | 2023-06-11 | | 5 | 一念之插 | 张灵玉 | 2023-06-11 | +---------------+------------------+-------------------+-----------------+ 5 rows in set (0.00 sec) 查SELECT语句 (实际对大小写不敏感)SELECT 语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 SELECT * FROM table_name; mysql&gt; select * from mydatabase_tbl; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 1 | MySQL学习 | YM学渣 | 2023-06-08 | | 2 | 阿威十八式 | 宝儿姐 | 2023-06-10 | | 3 | 不摇碧莲 | 张楚岚 | 2023-06-10 | +---------------+------------------+-------------------+-----------------+ 3 rows in set (0.00 sec) SELECT column1, column2,FROM table_name; mysql&gt; select submission_date,mydatabase_title from mydatabase_tbl; +-----------------+------------------+ | submission_date | mydatabase_title | +-----------------+------------------+ | 2023-06-08 | MySQL学习 | | 2023-06-10 | 阿威十八式 | | 2023-06-10 | 不摇碧莲 | +-----------------+------------------+ 3 rows in set (0.00 sec) mysql&gt; select submission_date from mydatabase_tbl; +-----------------+ | submission_date | +-----------------+ | 2023-06-08 | | 2023-06-10 | | 2023-06-10 | +-----------------+ 3 rows in set (0.00 sec) SELECT DISTINCT 语法选取不重复的元素 SELECT DISTINCT column1, column2, FROM table_name; mysql&gt; select distinct submission_date from mydatabase_tbl; +-----------------+ | submission_date | +-----------------+ | 2023-06-08 | | 2023-06-10 | +-----------------+ 2 rows in set (0.00 sec) WHERE 子句where用于提取满足条件的数据 SELECT column1, column2, FROM table_name WHERE condition; 多个条件间用与或（and or） mysql&gt; select * from mydatabase_tbl where mydatabase_author = &#39;宝儿姐&#39;; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 2 | 阿威十八式 | 宝儿姐 | 2023-06-10 | +---------------+------------------+-------------------+-----------------+ 1 row in set (0.00 sec) mysql&gt; select mydatabase_title,mydatabase_author from mydatabase_tbl where mydatabase_id=3; +------------------+-------------------+ | mydatabase_title | mydatabase_author | +------------------+-------------------+ | 不摇碧莲 | 张楚岚 | +------------------+-------------------+ 1 row in set (0.00 sec) SQL ORDER BY 关键字ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序，默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。 SELECT column1, column2, FROM table_name ORDER BY column1, column2 ASC|DESC; mysql&gt; select mydatabase_title from mydatabase_tbl order by submission_date desc; +------------------+ | mydatabase_title | +------------------+ | 阿威十八式 | | 不摇碧莲 | | MySQL学习 | +------------------+ 3 rows in set (0.00 sec) 查看数据库中的用户：mysql&gt; select user from user; +------------------+ | user | +------------------+ | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 4 rows in set (0.00 sec) 添加用户，用户名为guest，密码为guest123：mysql -u root -p mysql&gt; create user &#39;guest&#39;@&#39;localhost&#39; identified by &#39;guest123&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; select user from user; +------------------+ | user | +------------------+ | guest | | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 5 rows in set (0.00 sec) 删除guest:mysql&gt; drop user &#39;guest&#39;@&#39;localhost&#39;; Query OK, 0 rows affected (0.00 sec) mysql&gt; select user from user; +------------------+ | user | +------------------+ | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 4 rows in set (0.00 sec) 创建数据库：mysql&gt; create database mydatabase; Query OK, 1 row affected (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mydatabase | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.01 sec) 选择数据库：mysql&gt; use mydatabase; Database changed 删除数据库：mysql&gt; drop database mydatabase; Query OK, 0 rows affected (0.00 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) MySQL数据类型：https://www.runoob.com/mysql/mysql-data-types.html 创建数据表：mysql&gt; create table mydatabase_tbl( -&gt; mydatabase_id int not null auto_increment, -&gt; mydatabase_title varchar(100) not null, -&gt; mydatabase_author varchar(40) not null, -&gt; submission_date DATE, -&gt; primary key ( mydatabase_id ) -&gt; )engine=InnoDB default charset=utf8; Query OK, 0 rows affected, 1 warning (0.01 sec) 查看表的结构 mysql&gt; show tables; +----------------------+ | Tables_in_mydatabase | +----------------------+ | mydatabase_tbl | +----------------------+ 1 row in set (0.00 sec) mysql&gt; desc mydatabase_tbl; +-------------------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------------------+--------------+------+-----+---------+----------------+ | mydatabase_id | int | NO | PRI | NULL | auto_increment | | mydatabase_title | varchar(100) | NO | | NULL | | | mydatabase_author | varchar(40) | NO | | NULL | | | submission_date | date | YES | | NULL | | +-------------------+--------------+------+-----+---------+----------------+ 4 rows in set (0.00 sec) LIKE 子句%表示任意字符，类似unix中的*‘%a’ &#x2F;&#x2F;以a结尾的数据‘a%’ &#x2F;&#x2F;以a开头的数据‘%a%’ &#x2F;&#x2F;含有a的数据‘a‘ &#x2F;&#x2F;三位且中间字母是a的‘a’ &#x2F;&#x2F;两位且结尾字母是a的‘a‘ &#x2F;&#x2F;两位且开头字母是a的 SQL SELECT 语句使用 LIKE 子句从数据表中读取数据的通用语法：SELECT field1, field2,...fieldN FROM table_name WHERE field1 LIKE condition1 [AND [OR]] filed2 = &#39;somevalue&#39; mysql&gt; select mydatabase_title,mydatabase_author from mydatabase_tbl where mydatabase_title like &#39;%一%&#39;; +------------------+-------------------+ | mydatabase_title | mydatabase_author | +------------------+-------------------+ | 机智一匹 | 宝儿姐 | | 一念之插 | 张灵玉 | +------------------+-------------------+ 2 rows in set (0.00 sec) 表结构的复制：mysql&gt; create table tb2 like tb1; 表结构的复制同时拷贝数据：mysql&gt; create table tb2 select * from tb1; MySQL UNION 操作符MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。 SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions] UNION [ALL | DISTINCT] SELECT expression1, expression2, ... expression_n FROM tables [WHERE conditions]; MySQL 排序我们知道从 MySQL 表中使用 SQL SELECT 语句来读取数据。 如果我们需要对读取的数据进行排序，我们就可以使用 MySQL 的 ORDER BY 子句来设定你想按哪个字段哪种方式来进行排序，再返回搜索结果。SELECT field1, field2,...fieldN FROM table_name1, table_name2... ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]] mysql&gt; select * from tb00 order by submission_date desc; +---------------+------------------+-------------------+-----------------+ | mydatabase_id | mydatabase_title | mydatabase_author | submission_date | +---------------+------------------+-------------------+-----------------+ | 4 | 亿贫如洗 | 王道长 | 2023-06-11 | | 5 | 一念之插 | 张灵玉 | 2023-06-11 | | 3 | 不摇碧莲 | 张楚岚 | 2023-06-10 | | 2 | 机智一匹 | 宝儿姐 | 2023-06-09 | +---------------+------------------+-------------------+-----------------+ 4 rows in set (0.00 sec) MySQL GROUP BY 语句GROUP BY 语句根据一个或多个列对结果集进行分组。 在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。 SELECT column_name, function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; mysql&gt; select submission_date,count() from tb00 group by submission_date; +—————–+———-+ | submission_date | count() | +—————–+———-+ | 2023-06-09 | 1 | | 2023-06-10 | 1 | | 2023-06-11 | 2 | +—————–+———-+ 3 rows in set (0.00 sec) Python连接mysql$ python3 -m pip install PyMySQL 12345678910111213141516import pymysql# 打开数据库连接db = pymysql.connect(host = &quot;localhost&quot;, user = &quot;root&quot;, password = &quot;12345&quot;, database = &#x27;mydatabase&#x27;)# 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor()# 使用 execute() 方法执行 SQL 查询 cursor.execute(&quot;select * from mydatabase_tbl&quot;)# 使用 fetchone() 方法获取单条数据.data = cursor.fetchone()print(f&quot;Database_vision:&#123;data&#125;&quot;)# 关闭数据库连接db.close()","link":"","tags":[{"name":"mysql","slug":"mysql","permalink":"http://example.com/tags/mysql/"}]},{"title":"C++ 联合体","date":"2022-06-05T02:56:17.000Z","path":"2022/06/05/Union/","text":"处理相同的数据 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;struct vector1&#123; float x,y;&#125;;struct vector2&#123; union&#123; //匿名union //成员间对应变量共用相同内存 struct&#123; //成员1 float x,y,z,w; &#125;; struct&#123; //成员2 vector1 a,b; &#125;; &#125;; &#125;;int main()&#123; union U&#123; int a[10]; int b; &#125;; U u; std::cout&lt;&lt;&amp;u.b&lt;&lt;std::endl; //0x7f08bffb60 std::cout&lt;&lt;u.a&lt;&lt;std::endl; //0x7f08bffb60 共用相同内存 vector2 v = &#123;1.1f, 2.2f, 3.3f, 4.4f&#125;; std::cout&lt;&lt;v.a.x; //1.1 std::cout&lt;&lt;v.a.y; //2.2 std::cout&lt;&lt;v.b.x; //3.3 std::cout&lt;&lt;v.b.y; //4.4 &#125;","link":"","tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"java配置","date":"2021-06-06T09:13:35.000Z","path":"2021/06/06/java配置/","text":"jdk下载：https://www.oracle.com/ 1234&gt;&gt;java -versionjava version &quot;20.0.1&quot; 2023-04-18Java(TM) SE Runtime Environment (build 20.0.1+9-29)Java HotSpot(TM) 64-Bit Server VM (build 20.0.1+9-29, mixed mode, sharing) hello_world.java 12345public class hello_world&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello world!&quot;); &#125;&#125; javac jdk提供的编译工具进行编译javac hello_world.java 123456λ tree/f 卷 软件 的文件夹 PATH 列表 卷序列号为 0503-CB42 D:. hello_world.class hello_world.java java运行java hello_world Hello world!","link":"","tags":[{"name":"java学习","slug":"java学习","permalink":"http://example.com/tags/java%E5%AD%A6%E4%B9%A0/"}]},{"title":"hexo搭建博客笔记","date":"2021-05-07T06:48:23.000Z","path":"2021/05/07/hexo搭建博客笔记/","text":"下载安装Git，nodeJS 下载安装Git，nodeJS 之后使用blog目录下Git Bash进行操作 _config.yml配置(配置后才能部署到自己的GitHub仓库)1234deploy: type: git repo: https://github.com/xxxx/xxxx.github.io.git branch: master 安装指令-安装hexo框架npm install hexo-cli -g-初始化博客hexo init myblog-安装主题，到init生成的myblog根目录下 git clone theme-url themes/theme-name写新文章hexo new &quot;文章&quot;安装部署插件npm install hexo-deployer-git --save部署到github,部署前需要注册GitHub账号，新建一个仓库清除了之前生成的东西hexo clean生成静态文章，缩写hexo ghexo generate启动服务本地预览，缩写hexo shexo server部署文章,缩写hexo dhexo deployer使用yilia-plus主题：https://zhousiwei.gitee.io/yilia-plus-demo/2019/08/01/hexo%E4%B8%BB%E9%A2%98%E4%B9%8Bhexo-theme-yilia-plus/参考网址https://blog.csdn.net/sinat_37781304/article/details/82729029yilia-plus主题：https://gitee.com/nate-lin/yilia-plus/","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"软件分享","date":"2021-05-07T06:48:23.000Z","path":"2021/05/07/动画绘画软件分享/","text":"软件分享： 2d动画绘画软件分享：链接： https://pan.baidu.com/s/1_upZ4siX2Lr160zjW5A_Yg 提取码：mymk","link":"","tags":[]},{"title":"记录每日好心情","date":"2021-05-07T06:48:23.000Z","path":"2021/05/07/随笔/","text":"随笔 写下每日的心情不知道干什么，先随便找点东西学着！","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/tags/%E9%9A%8F%E7%AC%94/"}]}]